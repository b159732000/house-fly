<!DOCTYPE html>
<html lang="en">

<head>
	<title></title>
	<meta charset="utf-8">
	<meta name="generator" content="Three.js Editor">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!-- <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script> -->
	<style>
		body {
			font-family: sans-serif;
			font-size: 13px;
			background-color: #000;
			margin: 0px;
			overflow: hidden;

		}

		/* .loadingPage{
			position: absolute;
			top: 50%;
			height: 100px;
			width: 100px;
		}
		.loadingPage p{
			color: #fff;
			text-align: center;
		} */
	</style>
</head>

<body ontouchstart="">

	<div id="log"
		style="
    position: fixed; background: #fff; color: black; padding: 20px; bottom: 20px; left: 20px; width: 1500px; font: normal 12px/18px Monospace, Arial, Helvetical, sans-serif; text-align: left; border: 3px double #ddd; z-index: 3;">
	</div>


	<!-- 按鈕 -->
	<button onclick="logCamera()">console.log(camera)</button>
	<button onclick="changeCameraView1()">change camera view 1</button>
	<button onclick="changeCameraView2()">change camera view 2</button>
	<button onclick="ChangeCameraTarget('cameraTargetX')">change camera target x</button>
	<button onclick="ChangeCameraTarget('cameraTargetY')">change camera target y</button>
	<button onclick="ChangeCameraTarget('cameraTargetZ')">change camera target z</button>



	<script src="./js/three.js"></script>
	<script src="./js/OrbitControls.js"></script>
	<script src="./js/FBXLoader.js"></script>
	<script src="./js/inflate.min.js"></script>
	<!-- <script src="js/OBJLoader.js"></script> -->
	<script src="./js/Lensflare.js"></script>
	<script src="./js/TGALoader.js"></script>
	<!-- <script src="./js/tweenjs.js"></script> -->
	<script src="./js/FirstPersonControls.js"></script>
	<script src="./js/physi.js"></script>

	<!-- <script src="js/Sky.js"></script> -->
	<script>
		var sky, sunSphere;
		var scene = new THREE.Scene();

		//添加相机
		var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
		camera.position.set(0, 1000, 100);

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		//添加CubeMap
		var path = "pic/";
		var format = ".jpg";
		var urls = [
			path + 'px' + format, path + 'nx' + format,
			path + 'py' + format, path + 'ny' + format,
			path + 'pz' + format, path + 'nz' + format
		]
		var reflectionCube = new THREE.CubeTextureLoader().load(urls);
		reflectionCube.format = THREE.RGBFormat;
		var refractionCube = new THREE.CubeTextureLoader().load(urls);
		refractionCube.mapping = THREE.CubeRefractionMapping;
		refractionCube.format = THREE.RGBFormat;

		scene.background = reflectionCube;



		//添加直射光
		var dirLight = new THREE.DirectionalLight();
		dirLight.position.set(0, 0, 300);
		dirLight.color.setHSL(0.1, 0.7, 0.5);
		scene.add(dirLight);

		var textureLoader = new THREE.TextureLoader();
		var textureFlare0 = textureLoader.load('pic/lensflare0.png');
		var textureFlare3 = textureLoader.load('pic/lensflare3.png');
		addLight(0.55, 0.9, 0.5, 5000, 2000, 5000);
		addLight(0.08, 0.8, 0.5, 5000, 2000, 5000);
		addLight(0.995, 0.5, 0.9, 5000, 2000, 5000);

		function addLight(h, s, l, x, y, z) {
			var light = new THREE.PointLight(0xffffff, 1.5, 2000);
			light.color.setHSL(h, s, l);
			light.position.set(x, y, z);
			scene.add(light);
			var lensflare = new THREE.Lensflare();
			lensflare.addElement(new THREE.LensflareElement(textureFlare0, 700, 0, light.color));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 60, 0.6));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 70, 0.7));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 120, 0.9));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 70, 1));
			light.add(lensflare);
		}

		//相机控制器
		var controls = new THREE.OrbitControls(camera);

		controls.enableZoom = true;
		controls.minDistance = 0;
		controls.maxDistance = 1000;
		controls.enableDamping = true;
		controls.dampingFactor = 0.2;
		controls.rotateSpeed = 0.5;
		controls.maxPolarAngle = Math.PI / 2;

		//读取FBX模型
		var loader = new THREE.FBXLoader();
		var texLoader = new THREE.TGALoader();

		loader.load('lwf/1111.fbx', function (object) {
			object.traverse(function (child) {

				if (child.isMesh) {

					var texture1 = texLoader.load('lwf/' + child.name + 'VRay完成贴图.tga');
					var materal1 = new THREE.MeshBasicMaterial({
						map: texture1,
						transparent: true
					});
					child.material = materal1;
					child.castShadow = true;
					child.lights = true;
				}

			})


			object.scale.set(0.05, 0.05, 0.05);
			scene.add(object);
		})



		//按鈕輸出相機log
		function printCameraLog() {

			document.getElementById('log').innerHTML = "camera.position.x = " + camera.position.x + "<br>camera.position.y = " +
				camera.position.y + "<br>camera.position.z = " + camera.position.z +
				"<br>camera.rotation._x = " + camera.rotation._x + "<br>camera.rotation._y = " + camera.rotation._y +
				"<br>camera.rotation._z = " + camera.rotation._z;
		}


		//渲染動畫
		function animate() {
			// cube.rotation.x+=0.1;
			// cube.rotation.y+=0.1;
			controls.update();
			// fpControls.update(clock.getDelta());
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
			printCameraLog();
		}
		animate();



		//控制相機隨滑鼠移動
		function logCamera() {
			console.log(camera);
		}

		function changeCameraView1() {
			camera.position.set(1.52, 49.08, -407.62);
			camera.rotation.set(-3.14, 0.31, 3.14);
		}

		function changeCameraView2() {
			camera.position.set(-97.94, 55.70, -93.74);
			camera.rotation.set(-8.023, -0.436, -3.39);
			// camera.rotation.set(-4.66, -0.40, -1.85);
		}

		//相機注視的點
		var cameraTargetX = 100,
				cameraTargetY = 100,
				cameraTargetZ = 100;
		controls.target.x = cameraTargetX;
		controls.target.y = cameraTargetY;
		controls.target.z = cameraTargetZ;
		console.log(controls.target);

		//控制相機注視的點，每按一下按鈕該軸向+10
		function ChangeCameraTarget(axial) {
			if (axial == "cameraTargetX") {
				cameraTargetX += 10;
			}
			if (axial == "cameraTargetY") {
				cameraTargetY += 10;
			}
			if (axial == "cameraTargetZ") {
				cameraTargetZ += 10;
			}
			controls.target.x = cameraTargetX;
			controls.target.y = cameraTargetY;
			controls.target.z = cameraTargetZ;
			console.log(controls.target);
			return axial;
		}

		//在相機注視點生成球體
		var sphereR = 10;
		var sphereGeo = new THREE.SphereGeometry(sphereR, sphereR, sphereR);
		var sphereMat = new THREE.MeshLambertMaterial({
			color: 0x0000FF, wireframe: false
		})
		var sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
		sphereMesh.position.set(cameraTargetX, cameraTargetY, cameraTargetZ);
		scene.add(sphereMesh);

		//移除場景中最後一個新增的物件




		// var fpControls;
		// fpControls = new THREE.FirstPersonControls(camera);
		// function initControls() {

		//     fpControls.lookSpeed = 0.2; //鼠标移动查看的速度
		//     fpControls.movementSpeed = 20; //相机移动速度
		//     fpControls.noFly = true;
		//     fpControls.constrainVertical = true; //约束垂直
		//     fpControls.verticalMin = 1.0;
		//     fpControls.verticalMax = 2.0;
		//     fpControls.lon = -100; //进入初始视角x轴的角度
		//     fpControls.lat = 0; //初始视角进入后y轴的角度
		// }


		// 物理引擎
		// var fp_mesh = new Physijs.BoxMesh(new THREE.CubeGeometry(4, 10, 4), Physijs.createMaterial(new THREE
		// 	.MeshPhongMaterial({
		// 		opacity: 0,
		// 		transparent: true
		// 	})), 1);
		// fp_mesh.position.set(0, 0, 0);
		// scene.add(fp_mesh);

		// var state = {
		// 	front: false,
		// 	back: false,
		// 	left: false,
		// 	right: false,
		// 	angle: 0
		// };

		// // document.addEventListener('keydown', onKeyDown, false);
		// // document.addEventListener('keyup', onKeyUp, false);   

		// var velocity = {
		// x: 0,
		// y: 0,
		// z: 0
		// };

		// direction = state.angle;
		// 	if (state.front && !state.left && !state.back && !state.right) {
		// 		direction += 0;
		// 	}
		// 	if (state.front && state.left && !state.back && !state.right) {
		// 		direction += 45;
		// 	}
		// 	if (!state.front && state.left && !state.back && !state.right) {
		// 		direction += 90;
		// 	}
		// 	if (!state.front && state.left && state.back && !state.right) {
		// 		direction += 135;
		// 	}
		// 	if (!state.front && !state.left && state.back && !state.right) {
		// 		direction += 180;
		// 	}
		// 	if (!state.front && !state.left && state.back && state.right) {
		// 		direction += 225;
		// 	}
		// 	if (!state.front && !state.left && !state.back && state.right) {
		// 		direction += 270;
		// 	}
		// 	if (state.front && !state.left && !state.back && state.right) {
		// 		direction += 315;
		// 	}

		// 	velocity.x = -Math.sin(direction * Math.PI / 180) * hmc.moveSpeed;
		// 	velocity.z = -Math.cos(direction * Math.PI / 180) * hmc.moveSpeed;
		// 	fp_mesh.setLinearVelocity(velocity);
		// 	scene.simulate(undefined, 1);

		// 	this.lookSpeed = 0.2;

		// 	camera.position.x = fp_mesh.position.x + distance * Math.sin((help.position.x) * Math.PI / 360);
		// 	camera.position.z = fp_mesh.position.z + distance * Math.cos((help.position.x) * Math.PI / 360);
		// 	camera.position.y = fp_mesh.position.y + distance * Math.sin((help.position.y) * Math.PI / 360);
		// 	camera.lookAt(fp_mesh.position);
	</script>
</body>

</html>