<!DOCTYPE html>
<html lang="en">

<head>
	<title></title>
	<meta charset="utf-8">
	<meta name="generator" content="Three.js Editor">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!-- <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script> -->
	<style>
		body {
			font-family: sans-serif;
			font-size: 13px;
			background-color: #000;
			margin: 0px;
			overflow: hidden;

		}

		/* .loadingPage{
			position: absolute;
			top: 50%;
			height: 100px;
			width: 100px;
		}
		.loadingPage p{
			color: #fff;
			text-align: center;
		} */
	</style>
</head>

<body ontouchstart="">

	<div id="log"
		style="
    position: fixed; background: #fff; color: black; padding: 20px; bottom: 20px; left: 20px; width: 1500px; font: normal 12px/18px Monospace, Arial, Helvetical, sans-serif; text-align: left; border: 3px double #ddd; z-index: 3;">
	</div>


	<!-- 按鈕 -->
	<button onclick="logCamera()">console.log(camera)</button>
	<button onclick="changeCameraView1()">change camera view 1</button>
	<button onclick="changeCameraView2()">change camera view 2</button>
	<button onclick="ChangeCameraTarget('cameraTargetX')">change camera target x</button>
	<button onclick="ChangeCameraTarget('cameraTargetY')">change camera target y</button>
	<button onclick="ChangeCameraTarget('cameraTargetZ')">change camera target z</button>
	<button onclick="removeCube()">remove last cube</button>



	<script src="./js/three.js"></script>
	<script src="./js/OrbitControls.js"></script>
	<script src="./js/FBXLoader.js"></script>
	<script src="./js/inflate.min.js"></script>
	<!-- <script src="js/OBJLoader.js"></script> -->
	<script src="./js/Lensflare.js"></script>
	<script src="./js/TGALoader.js"></script>
	<!-- <script src="./js/tweenjs.js"></script> -->
	<script src="./js/FirstPersonControls.js"></script>
	<script src="./js/physi.js"></script>

	<!-- <script src="js/Sky.js"></script> -->
	<script>
		var sky, sunSphere;
		var scene = new THREE.Scene();

		//添加相机
		var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
		camera.position.set(0, 1000, 100);

		var renderer = new THREE.WebGLRenderer();
		//下面為加了抗鋸齒
		// var renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		//添加CubeMap
		var path = "pic/";
		var format = ".jpg";
		var urls = [
			path + 'px' + format, path + 'nx' + format,
			path + 'py' + format, path + 'ny' + format,
			path + 'pz' + format, path + 'nz' + format
		]
		var reflectionCube = new THREE.CubeTextureLoader().load(urls);
		reflectionCube.format = THREE.RGBFormat;
		var refractionCube = new THREE.CubeTextureLoader().load(urls);
		refractionCube.mapping = THREE.CubeRefractionMapping;
		refractionCube.format = THREE.RGBFormat;

		scene.background = reflectionCube;



		//添加直射光
		var dirLight = new THREE.DirectionalLight();
		dirLight.position.set(0, 0, 300);
		dirLight.color.setHSL(0.1, 0.7, 0.5);
		scene.add(dirLight);

		var textureLoader = new THREE.TextureLoader();
		var textureFlare0 = textureLoader.load('pic/lensflare0.png');
		var textureFlare3 = textureLoader.load('pic/lensflare3.png');
		addLight(0.55, 0.9, 0.5, 5000, 2000, 5000);
		addLight(0.08, 0.8, 0.5, 5000, 2000, 5000);
		addLight(0.995, 0.5, 0.9, 5000, 2000, 5000);

		function addLight(h, s, l, x, y, z) {
			var light = new THREE.PointLight(0xffffff, 1.5, 2000);
			light.color.setHSL(h, s, l);
			light.position.set(x, y, z);
			scene.add(light);
			var lensflare = new THREE.Lensflare();
			lensflare.addElement(new THREE.LensflareElement(textureFlare0, 700, 0, light.color));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 60, 0.6));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 70, 0.7));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 120, 0.9));
			lensflare.addElement(new THREE.LensflareElement(textureFlare3, 70, 1));
			light.add(lensflare);
		}

		//相机控制器
		var controls = new THREE.OrbitControls(camera);

		controls.enableZoom = true;
		controls.minDistance = 0;
		controls.maxDistance = 1000;
		controls.enableDamping = true;
		controls.dampingFactor = 0.2;
		controls.rotateSpeed = 0.5;
		controls.maxPolarAngle = Math.PI / 2;

		//读取FBX模型
		var loader = new THREE.FBXLoader();
		var texLoader = new THREE.TGALoader();

		loader.load('lwf/1111.fbx', function (object) {
			object.traverse(function (child) {

				if (child.isMesh) {

					var texture1 = texLoader.load('lwf/' + child.name + 'VRay完成贴图.tga');
					var materal1 = new THREE.MeshBasicMaterial({
						map: texture1,
						transparent: true
					});
					child.material = materal1;
					child.castShadow = true;
					child.lights = true;
				}

			})


			object.scale.set(0.05, 0.05, 0.05);
			scene.add(object);
		})



		//按鈕輸出相機log
		function printCameraLog() {

			document.getElementById('log').innerHTML = "camera.position.x = " + camera.position.x + "<br>camera.position.y = " +
				camera.position.y + "<br>camera.position.z = " + camera.position.z +
				"<br>camera.rotation._x = " + camera.rotation._x + "<br>camera.rotation._y = " + camera.rotation._y +
				"<br>camera.rotation._z = " + camera.rotation._z;
		}


		//渲染動畫
		function animate() {
			// cube.rotation.x+=0.1;
			// cube.rotation.y+=0.1;
			controls.update();
			// fpControls.update(clock.getDelta());
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
			printCameraLog();
		}
		animate();



		//控制相機隨滑鼠移動
		function logCamera() {
			console.log(camera);
		}

		function changeCameraView1() {
			camera.position.set(1.52, 49.08, -407.62);
			camera.rotation.set(-3.14, 0.31, 3.14);
		}

		function changeCameraView2() {
			camera.position.set(-97.94, 55.70, -93.74);
			camera.rotation.set(-8.023, -0.436, -3.39);
			// camera.rotation.set(-4.66, -0.40, -1.85);
		}

		//相機注視的點
		var cameraTargetX = 100,
			cameraTargetY = 100,
			cameraTargetZ = 100;
		controls.target.x = cameraTargetX;
		controls.target.y = cameraTargetY;
		controls.target.z = cameraTargetZ;
		console.log(controls.target);

		//控制相機注視的點，每按一下按鈕該軸向+10
		function ChangeCameraTarget(axial) {
			if (axial == "cameraTargetX") {
				cameraTargetX += 10;
			}
			if (axial == "cameraTargetY") {
				cameraTargetY += 10;
			}
			if (axial == "cameraTargetZ") {
				cameraTargetZ += 10;
			}
			controls.target.x = cameraTargetX;
			controls.target.y = cameraTargetY;
			controls.target.z = cameraTargetZ;

			//更新注視點的黑球位置
			sphereMesh.position.set(cameraTargetX, cameraTargetY, cameraTargetZ);
			scene.add(sphereMesh);

			console.log(controls.target);
			return axial;
		}

		//在相機注視點生成球體
		var sphereR = 10;
		var sphereGeo = new THREE.SphereGeometry(sphereR, sphereR, sphereR);
		var sphereMat = new THREE.MeshLambertMaterial({
			color: 0x0000FF,
			wireframe: false
		})
		var sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
		sphereMesh.position.set(cameraTargetX, cameraTargetY, cameraTargetZ);
		scene.add(sphereMesh);

		// //移除場景中最後一個新增的物件
		// function removeCube() {
		// 	var allChildren = scene.children;
		// 	var lastObject = allChildren[allChildren.length - 1];
		// 	if (lastObject instanceof THREE.Mesh) {
		// 		scene.remove(lastObject);
		// 		this.numberOfObjects = scene.children.length;
		// 	}}



			// var fpControls;
			// fpControls = new THREE.FirstPersonControls(camera);
			// function initControls() {

			//     fpControls.lookSpeed = 0.2; //鼠标移动查看的速度
			//     fpControls.movementSpeed = 20; //相机移动速度
			//     fpControls.noFly = true;
			//     fpControls.constrainVertical = true; //约束垂直
			//     fpControls.verticalMin = 1.0;
			//     fpControls.verticalMax = 2.0;
			//     fpControls.lon = -100; //进入初始视角x轴的角度
			//     fpControls.lat = 0; //初始视角进入后y轴的角度
			// }


			// 物理引擎
			// var fp_mesh = new Physijs.BoxMesh(new THREE.CubeGeometry(4, 10, 4), Physijs.createMaterial(new THREE
			// 	.MeshPhongMaterial({
			// 		opacity: 0,
			// 		transparent: true
			// 	})), 1);
			// fp_mesh.position.set(0, 0, 0);
			// scene.add(fp_mesh);

			// var state = {
			// 	front: false,
			// 	back: false,
			// 	left: false,
			// 	right: false,
			// 	angle: 0
			// };

			// // document.addEventListener('keydown', onKeyDown, false);
			// // document.addEventListener('keyup', onKeyUp, false);   

			// var velocity = {
			// x: 0,
			// y: 0,
			// z: 0
			// };

			// direction = state.angle;
			// 	if (state.front && !state.left && !state.back && !state.right) {
			// 		direction += 0;
			// 	}
			// 	if (state.front && state.left && !state.back && !state.right) {
			// 		direction += 45;
			// 	}
			// 	if (!state.front && state.left && !state.back && !state.right) {
			// 		direction += 90;
			// 	}
			// 	if (!state.front && state.left && state.back && !state.right) {
			// 		direction += 135;
			// 	}
			// 	if (!state.front && !state.left && state.back && !state.right) {
			// 		direction += 180;
			// 	}
			// 	if (!state.front && !state.left && state.back && state.right) {
			// 		direction += 225;
			// 	}
			// 	if (!state.front && !state.left && !state.back && state.right) {
			// 		direction += 270;
			// 	}
			// 	if (state.front && !state.left && !state.back && state.right) {
			// 		direction += 315;
			// 	}

			// 	velocity.x = -Math.sin(direction * Math.PI / 180) * hmc.moveSpeed;
			// 	velocity.z = -Math.cos(direction * Math.PI / 180) * hmc.moveSpeed;
			// 	fp_mesh.setLinearVelocity(velocity);
			// 	scene.simulate(undefined, 1);

			// 	this.lookSpeed = 0.2;

			// 	camera.position.x = fp_mesh.position.x + distance * Math.sin((help.position.x) * Math.PI / 360);
			// 	camera.position.z = fp_mesh.position.z + distance * Math.cos((help.position.x) * Math.PI / 360);
			// 	camera.position.y = fp_mesh.position.y + distance * Math.sin((help.position.y) * Math.PI / 360);
			// 	camera.lookAt(fp_mesh.position);
	</script>
</body>

</html>